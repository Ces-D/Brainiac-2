import datetime
import os
import pathlib
from configparser import ConfigParser
from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel

DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"


class ConfigError(Exception):
    pass


class ConfigKey(Enum):
    OPENAI_API_KEY = "openai_api_key"
    OPENAI_MODEL = "openai_model"
    """ Should not be relative. We assume its located relative to user or $HOME """
    OUTPUT_DIRECTORY = "output_directory_path"
    AUTHOR = "author"
    METADATA_STORAGE_NAME = "metadata_storage_name"


class BrainiacConfig:
    def __init__(self, loc: Optional[str]):
        if loc is None:
            loc = "config.ini"
        parser = ConfigParser()
        found = parser.read(loc)
        if not found:
            raise FileNotFoundError(f"Config file not found: {loc}")
        self.parser = parser

    def get(self, key: ConfigKey) -> str:
        """
        Get the value of a configuration key.
        """
        match key:
            case ConfigKey.OPENAI_API_KEY:
                api_key = self.parser.get("Brainiac2", ConfigKey.OPENAI_API_KEY.value)
                return api_key
            case ConfigKey.OPENAI_MODEL:
                model = self.parser.get(
                    "Brainiac2", ConfigKey.OPENAI_MODEL.value, fallback="gpt-4.1-nano"
                )
                return model
            case ConfigKey.OUTPUT_DIRECTORY:
                output_directory = self.parser.get(
                    "Brainiac2", ConfigKey.OUTPUT_DIRECTORY.value
                )

                output_path = pathlib.Path(os.path.expanduser(output_directory))
                if not output_path.exists():
                    raise ConfigError(
                        f"Destination directory {output_path} does not exist."
                    )
                if not output_path.is_dir():
                    raise ConfigError(
                        f"Destination path {output_path} is not a directory."
                    )

                return output_path.as_posix()
            case ConfigKey.METADATA_STORAGE_NAME:
                metadata_storage_name = self.parser.get(
                    "Brainiac2",
                    ConfigKey.METADATA_STORAGE_NAME.value,
                    fallback="brainiac_metadata.json",
                )
                return metadata_storage_name
            case ConfigKey.AUTHOR:
                author = self.parser.get("Brainiac2", ConfigKey.AUTHOR.value)
                return author


class Genre(str, Enum):
    Opinion = "OPINION"
    Technology = "TECHNOLOGY"
    Lifestyle = "LIFESTYLE"


class AnalyticsMetadata(BaseModel):
    created_at: str
    length_in_words: int
    reading_time_in_minutes: int


class InterestMetadata(BaseModel):
    keywords: List[str]
    genre: Genre
    related_articles: List[str]


class Metadata(BaseModel):
    """
    Metadata class for the article. Contains all information currently gathered and generated from an article source
    """

    title: str
    description: str
    author: str
    slug: str
    analytics: AnalyticsMetadata
    interest: InterestMetadata


class MetadataGeneratedResponse(BaseModel):
    """Generated by the AI model. Contains a series of fields that have no dependencies other than the article itself"""

    title: str
    description: str
    keywords: List[str]
    genre: Genre


class InterestMetadataGeneratedResponse(BaseModel):
    """Generated by the AI model. Contains a series of fields that have dependencies on the aggregated metadata object and the article itself"""

    related_articles: List[str]


class MetadataFile(BaseModel):
    """The shape of the aggregated metadata."""

    updated: str = datetime.datetime.now().strftime(DATETIME_FORMAT)
    metadata: Dict[str, Metadata]

    def push(self, data: Metadata):
        if data.slug in self.metadata:
            raise ValueError(f"Metadata with slug {data.slug} already exists.")
        self.metadata.update({data.slug: data})
        self.updated = datetime.datetime.now().strftime(DATETIME_FORMAT)
